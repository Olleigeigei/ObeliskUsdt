# ObeliskUSDT 使用说明-接入文档

## 1. 文档目的

本文件用于指导宿主项目快速接入 `ObeliskUSDT`，实现网页支付与机器人支付。

## 2. 接入前准备

- Node.js 18+
- Sequelize（MySQL 或兼容方言）
- Redis
- TronGrid / TronScan API Key

## 3. 安装

```bash
npm i @obeliskstudio/obelisk-usdt
```

在线环境建议固定从 npm 拉取：

```bash
npm i @obeliskstudio/obelisk-usdt@latest
```

安装后验证：

```bash
npm ls @obeliskstudio/obelisk-usdt
```

包地址：`https://www.npmjs.com/package/@obeliskstudio/obelisk-usdt`

已发布版本也可通过本地 tgz 安装：

```bash
npm i ./package/obeliskusdt/obeliskstudio-obelisk-usdt-0.1.0.tgz
```

## 3.1 打包发布产物

```bash
npm run release:pack
```

执行后会生成：

- `package/obeliskusdt/*.tgz`
- `package/obeliskusdt/content/package/`
- `package/obeliskusdt/RELEASE_INFO.txt`

## 4. 初始化模块

```ts
import { initObeliskUSDT } from '@obeliskstudio/obelisk-usdt';

const usdt = initObeliskUSDT({
  sequelize,
  redis,
  logger,
  config: {
    network: 'mainnet',
    webUrl: process.env.WEB_URL || '',
    botUsername: process.env.BOT_USERNAME || '',
    trongridApiKey: process.env.TRONGRID_API_KEY,
    tronscanApiKey: process.env.TRONSCAN_API_KEY,
    apiAuthToken: process.env.OBL_USDT_API_AUTH_TOKEN || '',
    apiSignMaxSkewSeconds: 300,
  },
  authMiddleware: {
    optional: optionalAuth,
    required: requireAuth,
    admin: requireAdminAuth,
  },
  onOrderConfirmed: async (order) => {
    // 宿主业务发放逻辑，必须幂等
    await benefitService.grantByOrderNo(order.orderNo);
  },
});
```

## 5. 路由挂载与启动

```ts
app.use('/api', usdt.paymentRouter);
app.use('/api', usdt.adminRouter);

await usdt.startScanner();
usdt.registerScheduledTasks(cron);
```

## 6. 用户支付接口

- `POST /payment/create`
- `GET /payment/status/:orderNo`
- `POST /payment/cancel/:orderNo`

### 创建订单请求体

```json
{
  "bizOrderNo": "HOST-ORDER-10001",
  "baseAmount": "99.00",
  "ts": 1700000000,
  "nonce": "e1b4f0f3b7d24e62a3d6c9f78b7a4b12",
  "metadata": { "biz": "obeliskcard", "plan": "vip_year" },
  "signature": "请看下方签名算法"
}
```

字段说明：

- `bizOrderNo`：必填，宿主业务订单号（用于对账与幂等发放）
- `baseAmount`：必填，支付金额，必须大于 0，最多 2 位小数，建议用字符串传
- `ts`：必填，签名时间戳（支持秒或毫秒）
- `nonce`：必填，签名随机串（建议 16-32 字节 hex）
- `metadata`：可选，宿主自定义字段（用于对账与回调发放）
- `signature`：必填，HMAC-SHA256 签名

说明：

- 创建订单成功后会返回 `orderToken`，宿主必须保存（建议和 `orderNo`、`bizOrderNo` 一起落库）。
- `bizOrderNo` 幂等：同一 `bizOrderNo` 在“未过期 + 状态仍在支付中”时重复调用创建接口，会返回同一笔订单，不会重复创建与重复占用金额。
- 查询与取消订单时必须携带 `orderToken`：
  - Header：`x-obl-order-token: <orderToken>`
  - 或 Query：`?token=<orderToken>`

## 6.1 签名算法（HMAC-SHA256）

`POST /payment/create` 默认要求签名，防止创建接口被刷单与参数被篡改。

同时启用 `ts + nonce` 防重放：

- `ts` 超出允许时间窗口会拒绝（默认 300 秒，可通过 `apiSignMaxSkewSeconds` 调整）
- `nonce` 会写入 Redis（`SET NX EX`），同一个 nonce 只能用一次

参与签名字段（字段不存在或为空字符串则跳过）：

`bizOrderNo`, `baseAmount`, `ts`, `nonce`, `metadata`

生成规则：

1. 取参与签名字段，按 key 的 ASCII 字典序排序。
2. 拼接成 `key=value&key=value`，其中 value 做 `encodeURIComponent`。
3. `metadata` 做稳定 JSON 序列化。
4. 用 `apiAuthToken` 做 HMAC-SHA256，输出 hex 小写，作为 `signature`。

宿主可以把签名放在请求体 `signature` 字段，或 Header `x-obl-signature`。

## 7. 机器人支付接入

```ts
const result = await usdt.bot.createOrderWithQR({
  bizOrderNo: 'HOST-ORDER-10001',
  baseAmount: '99.00',
  metadata: { scene: 'bot' },
});

await bot.sendPhoto(chatId, result.qrPngBuffer, {
  caption: `订单号: ${result.orderNo}\n金额: ${result.actualAmount} USDT\n地址: ${result.walletAddress}`,
});
```

## 8. 回调与幂等

子包在订单完成后触发 `onOrderConfirmed`。宿主必须保证：

- 同一 `orderNo` 只发放一次
- 回调失败可重试
- 发放日志可追溯

## 9. 安全要求

- `POST /payment/create` 返回的 `orderToken` 必须保存
- 查询与取消必须携带 `orderToken`，作为校验凭证
- 密钥必须使用环境变量，不允许硬编码

## 10. 数据表

- `obl_payment_wallets`
- `obl_payment_orders`
- `obl_payment_transactions`

## 11. 宿主业务示例代码

```ts
import axios from 'axios';
import crypto from 'crypto';

type CreateOrderInput = {
  bizOrderNo: string;
  baseAmount: string;
  metadata?: Record<string, unknown> | null;
};

const apiAuthToken = process.env.OBL_USDT_API_AUTH_TOKEN || '';

function stableStringify(value: any): string {
  if (value === null || value === undefined) return '';
  if (typeof value === 'string') return JSON.stringify(value);
  if (typeof value === 'number') return JSON.stringify(Number.isFinite(value) ? value : null);
  if (typeof value === 'boolean') return JSON.stringify(value);
  if (Array.isArray(value)) return `[${value.map((v) => stableStringify(v)).join(',')}]`;
  if (typeof value === 'object') {
    const keys = Object.keys(value).sort();
    return `{${keys.map((k) => `${JSON.stringify(k)}:${stableStringify((value as any)[k])}`).join(',')}}`;
  }
  return JSON.stringify(String(value));
}

function buildSignature(payload: any, token: string): string {
  const picked: Record<string, string> = {};
  const fields = ['bizOrderNo', 'baseAmount', 'ts', 'nonce'];
  for (const f of fields) {
    const v = payload?.[f];
    const s = v === undefined || v === null ? '' : String(v).trim();
    if (s) picked[f] = s;
  }
  if (payload?.metadata && typeof payload.metadata === 'object') {
    const raw = stableStringify(payload.metadata);
    if (raw && raw !== '{}' && raw !== '[]') picked.metadata = raw;
  }

  const canonical = Object.keys(picked)
    .sort()
    .map((k) => `${k}=${encodeURIComponent(picked[k])}`)
    .join('&');

  return crypto.createHmac('sha256', token).update(canonical).digest('hex');
}

export async function createUsdtOrder(input: CreateOrderInput) {
  const payload = {
    bizOrderNo: input.bizOrderNo,
    baseAmount: input.baseAmount,
    ts: Math.floor(Date.now() / 1000),
    nonce: crypto.randomBytes(16).toString('hex'),
    metadata: input.metadata || { scene: 'web' },
  };
  const signature = buildSignature(payload, apiAuthToken);
  const res = await axios.post('/api/payment/create', {
    ...payload,
    signature,
  });
  return res.data?.data;
}

export async function waitUsdtOrderCompleted(orderNo: string, orderToken: string, maxTry = 100) {
  for (let i = 0; i < maxTry; i += 1) {
    const res = await axios.get(`/api/payment/status/${encodeURIComponent(orderNo)}`, {
      headers: { 'x-obl-order-token': orderToken },
    });
    const status = res.data?.data?.status;
    if (status === 'completed') return res.data?.data;
    if (status === 'expired' || status === 'cancelled' || status === 'failed') return res.data?.data;
    await new Promise((resolve) => setTimeout(resolve, 3000));
  }
  throw new Error('支付状态轮询超时');
}
```

## 12. 机器人完整下单示例（含失败兜底）

```ts
type BotLike = {
  sendPhoto: (chatId: number, photo: Uint8Array, options?: { caption?: string }) => Promise<void>;
  sendMessage: (chatId: number, text: string) => Promise<void>;
};

type USDTBotBridge = {
  createOrderWithQR: (params: {
    bizOrderNo: string;
    baseAmount: string;
    metadata?: Record<string, unknown> | null;
  }) => Promise<{
    orderNo: string;
    walletAddress: string;
    actualAmount: string;
    expiresAt: Date;
    qrPngBuffer: Uint8Array;
    paymentPageUrl: string;
  }>;
};

export async function createAndSendUsdtPaymentByBot(params: {
  bot: BotLike;
  usdtBotBridge: USDTBotBridge;
  chatId: number;
  bizOrderNo: string;
  baseAmount: string;
}) {
  try {
    const result = await params.usdtBotBridge.createOrderWithQR({
      bizOrderNo: params.bizOrderNo,
      baseAmount: params.baseAmount,
      metadata: { scene: 'bot' },
    });

    const expireText = new Date(result.expiresAt).toLocaleString('zh-CN', { hour12: false });
    const caption =
      `请使用 USDT(TRC20) 完成支付\n` +
      `订单号: ${result.orderNo}\n` +
      `业务单号: ${params.bizOrderNo}\n` +
      `金额: ${result.actualAmount} USDT\n` +
      `地址: ${result.walletAddress}\n` +
      `过期时间: ${expireText}`;

    await params.bot.sendPhoto(params.chatId, result.qrPngBuffer, { caption });
    await params.bot.sendMessage(params.chatId, `支付页面：${result.paymentPageUrl}`);

    return {
      ok: true,
      orderNo: result.orderNo,
      bizOrderNo: params.bizOrderNo,
    };
  } catch (error) {
    await params.bot.sendMessage(params.chatId, '创建支付订单失败，请稍后重试');
    return {
      ok: false,
      error: (error as Error)?.message || 'unknown_error',
      bizOrderNo: params.bizOrderNo,
    };
  }
}
```

## 13. 用户使用流程

### 13.1 初始化阶段（管理员）

1. 完成模块接入并启动扫描器。
2. 使用管理员账号登录后台。
3. 先创建至少 1 个收款钱包，再开放支付入口。

### 13.2 添加收款钱包（管理员）

接口：`POST /admin/payment/wallets`

请求体示例：

```json
{
  "address": "TXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
  "label": "主收款钱包",
  "isActive": true,
  "priority": 1
}
```

字段说明：

- `address`：TRON 钱包地址
- `label`：后台标识名称
- `isActive`：是否启用
- `priority`：优先级，数字越小越优先

建议操作：

- 先添加 2~3 个钱包用于分流。
- 通过 `GET /admin/payment/wallets` 检查钱包列表。
- 确认 `isActive = true` 后再开始收款。

### 13.3 钱包维护（管理员）

- 修改钱包：`PUT /admin/payment/wallets/:id`
- 禁用钱包：`PUT /admin/payment/wallets/:id`，传 `isActive=false`
- 删除钱包：`DELETE /admin/payment/wallets/:id`

说明：

- 禁用钱包后，新订单不会分配到该钱包。
- 已生成的历史订单不受影响，仍按原地址核对到账。

### 13.4 用户支付流程（网页）

1. 用户在宿主项目选择商品并创建业务单（`bizOrderNo`）。
2. 宿主调用 `POST /payment/create` 创建支付订单。
3. 页面展示二维码（地址 + 金额）。
4. 用户完成转账。
5. 页面轮询 `GET /payment/status/:orderNo`。
6. 状态变为 `completed`，展示支付成功页面。

### 13.5 用户支付流程（机器人）

1. 用户在机器人点击购买。
2. 宿主调用 `usdt.bot.createOrderWithQR` 创建支付订单。
3. 机器人发送二维码与支付信息。
4. 用户转账后等待链上确认。
5. 状态完成后由回调发放权益。

### 13.6 回调发放流程（宿主）

1. 子包触发 `onOrderConfirmed`。
2. 宿主按 `orderNo` 或 `bizOrderNo` 做幂等校验。
3. 发放业务权益。
4. 记录发放日志，便于审计和售后查询。

### 13.7 常见异常处理流程

- 创建订单失败：检查钱包是否存在可用地址、金额参数是否有效。
- 长时间未到账：检查用户是否转账到正确地址且金额完全一致。
- 已到账未完成：检查扫描器是否运行、确认数是否达标。
- 回调发放失败：写入失败日志并触发重试任务。

## 14. 商务与定制联系

- 需要定制或开发，业务联系：`@mhuai8`
